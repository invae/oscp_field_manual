# LD_PRELOAD-function-hooking

## intro and description

### dynamic linking

Dynamically linked binaries link together numerous shared libraries at execution time in order to extend functionality. The libraries that get linked to our binary are present in memory during execution. For example, a binary that writes files does not need to implement the API required to request those system calls. Instead, we can dynamically link libc, `/lib/i386-linux-gnu/libc.so.6` to gain access to the `write()` api. 


### implementation

When a `write()` call is done by the binary, it looks for first instance of the `write` symbol in the shared objects that have been loaded into memory. Using the found address, it prepares the arguments and executes the function at the found address.  Execution flow then returns to the main binary. 


### function hooking

You may have noticed in the implementation section that in calling the `write()` function, we search for the ***first*** instance of a symbol. If we can affect the order that the shared libraries are loaded into memory, we can replace the implementation of the `write()` function with our own customized one by placing it at a lower address. 

This can be done in many ways, but our focus will be on `LD_PRELOAD` environment variable and the file `/etc/ld.so.preload`. Due to the`/etc/ld.so.preload` file having a system-wide effect, it is of particular interest to red team operatives looking to improve their on-target OPSEC. 

The `LD_PRELOAD` environment variable is a path to a shared object to be loaded ***before*** all other shared objects. By writing a custom shared object that contains the symbol `write`, we can replace the implementation of libc's `write` with our own. It is even possible to reference libc's implementation of `write` to ensure that the typical user experience is unaffected by our function hooking. 

The file `/etc/ld.so.preload` is a  whitespace-seperated list of fully qualified paths to shared objects to be loaded before any others. In the event of the `/etc/ld.so.preload` file and `LD_PRELOAD` environment variable both being used, the environment variable is given precedence. 

This `/etc/ld.so.preload` file is not commonly found on systems and is usually only deployed as a temporary emergency workaround. The presence of this file may indicate compromise or tampering. This is of particular importance to red team operatives who need to practice on-target OPSEC. If operatives are going to be hooking functions, then they should also be implementing logic to mask their custom shared objects and the `/etc/ld.so.preload` file left on the disk. 


## hooking procedure

### write a shared object in C

The shared object we write can use just about whatever we want in terms of `#include` and logic. The following requirement must be satisified in order to successfully hook a library function:

1. the function signature of our custom function match signature of the library function
2. the return type of our custom function must match the return type of the library function

Failure to do so can create errors which result in OPSEC failures or program crashes.

It is possible to introduce logic which defers to the original library function by using:

1. `#include <dlfcn.h>`
2. a function pointer, we will call `lib_fucntion` in this document. Mimic the function signature and return type when declaring the function pointer
3. `lib_fucntion = dlsym(RTLD_NEXT, "write")`, to get the address of the next occurrence of the symbol. In this case we are grabbing the address of the `write` symbol in the original library.

With that setup, whenever we want to defer functionality to the original libary implementaiton we can call `lib_function(arg1,arg2,arg3)`.

### compiling and setting the preload

```bash
gcc -ldl custom_lib.c -fPIC -shared -D_GNU_SOURCE -o OPSEC_SENSITIVE_NAME.so
```

We can set the preload through `LD_PRELOAD` environment variables or in the `/etc/ld.so.preload` file

```bash
export LD_PRELOAD=/path/to/OPSEC_SENSITVE_NAME.so
```


### considerations

- 64bit vs 32bit: some libraries handle these seperately, if you are hooking a function that does so then you must write logic to handle both cases
- red team operatives should include hooks for library calls used by `/bin/ls` and `/bin/find` at a minimum to hide from basic detection methods
- custom shared objects should be written to disk in a OPSEC sensitve way, e.g. to appropriate directory for the operating system such as `/usr/lib` or `/lib`



## extensions

The careful study of library functions and how common utilities interact with them can result in creative opportunites for

- persistence
- on-target OPSEC
- intelligence gathering
- information exfiltration


